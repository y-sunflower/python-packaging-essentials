---
title: "Introduction to packaging"
---

Creating a Python package is all about making your code __reusable__, __shareable__, and __easy to install__. Whether you want to publish a library for the world or just organize your own projects better, understanding how packaging works is the first step.


## The `__init__.py` File

At its simplest, a package is just a folder that contains an `__init__.py` file.

```bash
my_package/
└── __init__.py
```

The presence of `__init__.py` tells Python: "this is a package."  

Even if it’s an empty file, it’s important—it allows you to import parts of your code like this:

```python
from my_package import something
```

Without it, Python treats the folder as a regular directory, **not something it can import from**.



## Package vs Module

These terms get thrown around a lot. Here's the quick breakdown:

- **Module**: A single `.py` file (e.g., `my_file.py`)
- **Package**: A directory with an `__init__.py`, possibly containing multiple modules (e.g., multiple files)



## PyPI (Python Package Index)

[PyPI](https://pypi.org) is the default online repository for Python packages. This is where packages are stored so that others can find and install them.

When you run:

```bash
pip install requests
```

You’re downloading the `requests` package from PyPI. More specifically, you’re downloading the package's distribution (which might be source code or precompiled binaries) to your local machine from PyPI servers.

## pip (and friends)

`pip` is the tool used to install packages from PyPI. It’s simple and widely supported.

Example:

```bash
pip install numpy
```

But when working with packages in Python, you need to take into account the package version. Maybe you need `numpy` `2.1.2` instead of `2.1.1` for your project.

You can read more about this in the [handling dependencies article](./handling-dependencies.html), but in summary, it's important to control the version of the packages you use/distribute, to ensure reproducible workflows and avoid unexpected things.

Some newer tools are built around `pip` to offer additional features such as **dependency management** and **better performance**.

One of the most important things these tools do is called dependency resolution, which involves calculating which versions of each package are compatible with each other based on version constraints. For example, you might be using a version of numpy that is incompatible (for whatever reason) with matplotlib, and since matplotlib relies on numpy, there's a problem.

Since 2024, the best tool available is called [uv](https://docs.astral.sh/uv/). It's super easy to use, super fast and does everything you need, in one place, with one tool. It's more of a Python project manager than a simple package installer.


