[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python Packaging Essentials",
    "section": "",
    "text": "Preface\n\nAbout\nThe aim of this site it to provide all the must known practices when it comes to create a Python package. It offers 10 blog posts, where each of them covers one topic with a few key points. The goal here is to empower anyone with just basic Python knowledge.\nWe’ll go over concrete examples, use clear explanations, and try as much as possible to go straight to the point so that anyone with some Python knowledge can create their own Python packages.\n\n\nGood to know\n\nAll blog posts are independant. Even if they follow some sort of order, it’s perfectly fine to just look at what interests you.\nThis site is open source and in continuous improvement. If you want to suggest an improvement (correct an error, improve an explanation, add an example or anything else), it’s more than welcomed. It starts here.\nYou can download the PDF version of this site in the top left of the site / navigation bar.\nThis website is not exhaustive and does not aim to be. We aim to focus on the key points and refer to other resources for more specific topics.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "introduction-to-packaging.html",
    "href": "introduction-to-packaging.html",
    "title": "1  Introduction to packaging",
    "section": "",
    "text": "1.1 The __init__.py File\nCreating a Python package is all about making your code reusable, shareable, and easy to install. Whether you want to publish a library for the world or just organize your own projects better, understanding how packaging works is the first step.\nAt its simplest, a package is just a folder that contains an __init__.py file.\nThe presence of __init__.py tells Python: “this is a package.”\nEven if it’s an empty file, it’s important—it allows you to import parts of your code like this:\nWithout it, Python treats the folder as a regular directory, not something it can import from.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to packaging</span>"
    ]
  },
  {
    "objectID": "introduction-to-packaging.html#the-__init__.py-file",
    "href": "introduction-to-packaging.html#the-__init__.py-file",
    "title": "1  Introduction to packaging",
    "section": "",
    "text": "my_package/\n└── __init__.py\n\n\nfrom my_package import something",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to packaging</span>"
    ]
  },
  {
    "objectID": "introduction-to-packaging.html#package-vs-module",
    "href": "introduction-to-packaging.html#package-vs-module",
    "title": "1  Introduction to packaging",
    "section": "1.2 Package vs Module",
    "text": "1.2 Package vs Module\nThese terms get thrown around a lot. Here’s the quick breakdown:\n\nModule: A single .py file (e.g., my_file.py)\nPackage: A directory with an __init__.py, possibly containing multiple modules (e.g., multiple files)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to packaging</span>"
    ]
  },
  {
    "objectID": "introduction-to-packaging.html#pypi-python-package-index",
    "href": "introduction-to-packaging.html#pypi-python-package-index",
    "title": "1  Introduction to packaging",
    "section": "1.3 PyPI (Python Package Index)",
    "text": "1.3 PyPI (Python Package Index)\nPyPI is the default online repository for Python packages. This is where packages are stored so that others can find and install them.\nWhen you run:\npip install requests\nYou’re downloading the requests package from PyPI. More specifically, you’re downloading the package’s distribution (which might be source code or precompiled binaries) to your local machine from PyPI servers.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to packaging</span>"
    ]
  },
  {
    "objectID": "introduction-to-packaging.html#pip-and-friends",
    "href": "introduction-to-packaging.html#pip-and-friends",
    "title": "1  Introduction to packaging",
    "section": "1.4 pip (and friends)",
    "text": "1.4 pip (and friends)\npip is the tool used to install packages from PyPI. It’s simple and widely supported.\nExample:\npip install numpy\nBut when working with packages in Python, you need to take into account the package version. Maybe you need numpy 2.1.2 instead of 2.1.1 for your project.\nYou can read more about this in the handling dependencies article, but in summary, it’s important to control the version of the packages you use/distribute, to ensure reproducible workflows and avoid unexpected things.\nSome newer tools are built around pip to offer additional features such as dependency management and better performance.\nOne of the most important things these tools do is called dependency resolution, which involves calculating which versions of each package are compatible with each other based on version constraints. For example, you might be using a version of numpy that is incompatible (for whatever reason) with matplotlib, and since matplotlib relies on numpy, there’s a problem.\nSince 2024, the best tool available is called uv. It’s super easy to use, super fast and does everything you need, in one place, with one tool. It’s more of a Python project manager than a simple package installer.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to packaging</span>"
    ]
  },
  {
    "objectID": "organize-a-package.html",
    "href": "organize-a-package.html",
    "title": "2  Organize a package",
    "section": "",
    "text": "2.1 Initialize the directory\nIn order to follow the steps below, you’ll need to have both Git and uv installed on your machine. Both are command-line tools, meaning you’ll use your terminal to run commands that perform various actions.\nLet’s assume we’re naming our Python package “sunflower”.\nThe very first step is to create a new directory named “sunflower”. Inside this directory, create another directory with the same name. The structure should look like this:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Organize a package</span>"
    ]
  },
  {
    "objectID": "organize-a-package.html#initialize-the-directory",
    "href": "organize-a-package.html#initialize-the-directory",
    "title": "2  Organize a package",
    "section": "",
    "text": "sunflower/\n└── sunflower/",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Organize a package</span>"
    ]
  },
  {
    "objectID": "organize-a-package.html#add-main-python-project-files",
    "href": "organize-a-package.html#add-main-python-project-files",
    "title": "2  Organize a package",
    "section": "2.2 Add main Python project files",
    "text": "2.2 Add main Python project files\nNext, we need to create a few essential files at the root of the project.\n\npyproject.tomlLICENSE.git/.gitignore.venv/README.mdsandbox.py\n\n\nAll the package metadata. It will contain a lot of useful information when we want to distribute this PyPI package so that everyone can install it easily.\nHere is a simple version of this file:\n[project]\nname = \"sunflower\"\ndescription = \"Description of the package\"\nversion = \"0.1.0\"\nlicense = \"MIT\"\nlicense-files = [\"LICENSE\"]\nkeywords = [\"sunflower\", \"yellow\"]\nauthors = [\n  { name=\"Your Name\", email=\"yourmail@gmail.com\" },\n]\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.9\"\nclassifiers = [\n    \"Programming Language :: Python :: 3\",\n    \"Operating System :: OS Independent\",\n]\ndependencies = []\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[project.urls]\nHomepage = \"https://github.com/yourname/sunflower\"\nIssues = \"https://github.com/yourname/sunflower/issues\"\n\n\nA basic text file containing the licence for your package. This licence is important because it tells other people what they are allowed to do with your package.\nIt is specific to each project, but you can find out more at choosealicence.com.\nHere is an example of the most common licence: the MIT licence.\nCopyright (c) 2025 Your Name\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n\nThis is a directory used internally by the Git software to track all changes in the project. Assuming that the first “sunflower” directory is in your Desktop/ directory, you should create this directory by running the git init command when you are in the Desktop/sunflower/ directory.\nIt’s very likely that you won’t see it, as most operating systems (Windows, MacOS, etc.) hide files/directories that start with ., but it doesn’t matter. This directory will be managed entirely by Git itself, so we recommend that you never make any manual changes to it.\n\n\nA file in which each line describes one or more files/directories that are not explicitly part of the project or are not relevant in general. Don’t worry too much about this, you can just start with the example content below.\nIt is very likely that you will not see it outside your code editor, as most operating systems (Windows, MacOS, etc.) hide files/directories that start with ., but that doesn’t matter.\n# Python-generated files\n__pycache__/\n*.py[oc]\nbuild/\ndist/\nwheels/\n*.egg-info\n\n# Virtual environments\n.venv/\nvenv/\n.env/\nenv/\n\n# VS code config\n.vscode/\n\n# files on mac\n.DS_Store\n\n# all cache files\n*cache*\n\n# Sandbox files\nsandbox.py\nsandbox.ipynb\n\n\nA directory containing all the things we need to work properly in our Python environment. It contains a Python interpreter, all the packages used in the project (e.g. numpy, requests, etc), and a few other things.\nThe best way to create one is to run uv venv.\nIt is very likely that you will not see it outside your code editor, as most operating systems (Windows, MacOS, etc.) hide files/directories that start with ., but that doesn’t matter.\n\n\nA markdown file that describes the project, gives advice on how to use it, install it and so on. There are no rules about what to do with this file, it’s just used to tell people what is the first thing they should read before using your package.\nFor example, it could be something like this:\n# sunflower: my cool Python package\n\nWelcome to the homepage of the `sunflower` project.\n\nIt's a new project, but it will be available soon!\n\n\nA file that we will use to test and use our package. It’s optional but very practical.\n\n\n\n\nAs you can see, we haven’t written a single line of Python code, yet we already have a lot of files and directories. The organisation of our project now looks like this:\nsunflower/\n├── sunflower/\n├── .git/\n├── .venv/\n├── .gitignore\n├── README.md\n├── LICENSE\n├── sandbox.py\n└── pyproject.toml",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Organize a package</span>"
    ]
  },
  {
    "objectID": "organize-a-package.html#add-python-code",
    "href": "organize-a-package.html#add-python-code",
    "title": "2  Organize a package",
    "section": "2.3 Add Python code",
    "text": "2.3 Add Python code\nWhen creating a Python package, we want to write a reusable piece of code, not just put in a few scripts that do things. To illustrate:\n\nNot reusable codeReusable code\n\n\n\nname = \"Joseph\"\nmessage = f\"Hello {name}\"\nprint(message)\n\nHello Joseph\n\n\nThis code does something: it prints a message.\n\n\n\ndef say_hello(name):\n   message = f\"Hello {name}\"\n   print(message)\n\nThe code above does ‘nothing’. The only thing it does is create a function object that will be stored in memory. I can now call it and it will execute some code. For example:\n\nsay_hello(\"Joseph\")\n\nHello Joseph\n\n\n\n\n\nHere, we’ll keep things simple and assume that we only want to provide functions and classes in our package.\nNow, let’s create our first Python module (which is just a file ending in .py). We’ll call it module1.py, but it can be anything. The only thing we want to stick to when naming files is:\n\nuse lowercase only\navoid spaces and odd characters\nkeep it short\nuse underscores “_”\n\n\nBad file namesGood file names\n\n\nmy file.py\nMyfile.py\nmyFile.py\nmy@file.py\nmy-file.py\nthis-file-does-this-and-that.py\n\n\nmy_file.py\nmyfile.py\n\n\n\nSo let’s put our module1.py in sunflower/sunflower/, which will give us:\nsunflower/\n├── sunflower/\n│   └── module1.py\n├── .git/\n├── .venv/\n├── .gitignore\n├── README.md\n├── LICENSE\n├── sandbox.py\n└── pyproject.toml\nIn module1.py, we’re going to add our very first function to our package. For example, we’ll create a count_sunflower() function. This function will count how many times the word ‘sunflower’ occurs in a given string.\nimport re\n\ndef count_sunflowers(s):\n   s = re.sub(r\"[^a-zA-Z\\s]\", \"\", s)  # Remove non-text characters\n   s = s.lower()                      # Convert to lowercase\n   n_sunflower = s.split().count(\"sunflower\")\n   n_sunflowers = s.split().count(\"sunflowers\")\n   return n_sunflower + n_sunflowers\nWe’re now going to add a __init__.py file in the same place as the module1.py file that contains our previous function. This is a special Python file. It tells Python that the sunflower/sunflower/ directory is a package, which will allow us to import functions from that package into the outside world.\nWe now have this:\nsunflower/\n├── sunflower/\n│   ├── __init__.py\n│   └── module1.py\n├── .git/\n├── .venv/\n├── .gitignore\n├── README.md\n├── LICENSE\n├── sandbox.py\n└── pyproject.toml\nThe __init__.py file should look like this:\nfrom .module1 import count_sunflowers\n\n__all__ = [\"count_sunflowers\"]\nAnd well done! You may not have realised it, but we already have a Python package that can be used with a function.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Organize a package</span>"
    ]
  },
  {
    "objectID": "organize-a-package.html#user-perspective",
    "href": "organize-a-package.html#user-perspective",
    "title": "2  Organize a package",
    "section": "2.4 User perspective",
    "text": "2.4 User perspective\nLet’s now look at how to use our package from the user’s point of view.\nOnce again, we’ll need to run a command in our terminal at Desktop/sunflower/:\nuv pip install -e .\nThis command will install our current package in editable mode. This allows us to test our package while making updates.\nThe next step is to open sandbox.py and write some code that uses our package.\nfrom sunflower import count_sunflower\n\ntext = \"\"\"\nSunflower petals bright and gold,  \nSunflower fields, a sight to behold.  \nSunflower dreams in the morning light,  \nBlooming softly, pure and bright.\n\"\"\"\n\nprint(count_sunflower(text))\n3\nNote that we can use any of the following syntaxes:\n\nSyntax 1Syntax 2Syntax 3\n\n\nfrom sunflower import count_sunflower\n\ntext = \"\"\"\nSunflower petals bright and gold,  \nSunflower fields, a sight to behold.  \nSunflower dreams in the morning light,  \nBlooming softly, pure and bright.\n\"\"\"\n\ncount_sunflower(text)\n\n\nimport sunflower\n\ntext = \"\"\"\nSunflower petals bright and gold,  \nSunflower fields, a sight to behold.  \nSunflower dreams in the morning light,  \nBlooming softly, pure and bright.\n\"\"\"\n\nsunflower.count_sunflower(text)\n\n\nimport sunflower as sfl # or any other alias like \"sf\" or \"sunflo\"\n\ntext = \"\"\"\nSunflower petals bright and gold,  \nSunflower fields, a sight to behold.  \nSunflower dreams in the morning light,  \nBlooming softly, pure and bright.\n\"\"\"\n\nsfl.count_sunflower(text)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Organize a package</span>"
    ]
  },
  {
    "objectID": "organize-a-package.html#add-an-internal-function",
    "href": "organize-a-package.html#add-an-internal-function",
    "title": "2  Organize a package",
    "section": "2.5 Add an internal function",
    "text": "2.5 Add an internal function\nWhen creating a package, it is very practical to create functions that we will use internally: inside the package itself.\nIf we go back to our previous example, we might want to have a separate function that takes a string and cleans it up by removing non-text characters and putting it in lower case. Let’s name this function _clean_string() and place it in a new file: module2.py.\nimport re\n\ndef _clean_string(s):\n   s = re.sub(r\"[^a-zA-Z\\s]\", \"\", s)  # Remove non-text characters\n   s = s.lower()  # Convert to lowercase\n   return s\nOur code in module1.py should now become:\nfrom .module2 import _clean_string\n\ndef count_sunflowers(s):\n   s = _clean_string(s)\n   n_sunflower = s.split().count(\"sunflower\")\n   n_sunflowers = s.split().count(\"sunflowers\")\n   return n_sunflower + n_sunflowers\nWe now have 2 functions:\n\ncount_sunflowers() a public function that users of the package will use.\n_clean_string() a private function used internally. The underscore (‘_’) at the beginning of the function name tells other people that it should not be used outside the package from which it came.\n\nNote that _clean_string() is still usable by users if they run it:\nfrom sunflower.module2 import _clean_string\nBut as you can see from the documentation blog post, we won’t have or create documentation on these functions, so they’re unlikely to find it anyway.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Organize a package</span>"
    ]
  },
  {
    "objectID": "organize-a-package.html#final-organization",
    "href": "organize-a-package.html#final-organization",
    "title": "2  Organize a package",
    "section": "2.6 Final organization",
    "text": "2.6 Final organization\nAfter all these steps, our package now looks like this:\nsunflower/\n├── sunflower/\n│   ├── __init__.py\n│   ├── module1.py\n│   └── module2.py\n├── .git/\n├── .venv/\n├── .gitignore\n├── README.md\n├── LICENSE\n├── sandbox.py\n└── pyproject.toml",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Organize a package</span>"
    ]
  },
  {
    "objectID": "handling-dependencies.html",
    "href": "handling-dependencies.html",
    "title": "3  Handling dependencies",
    "section": "",
    "text": "3.1 Specify dependencies\nDependencies are the external Python packages your code needs in order to work—like requests, numpy, or pandas.\nFor example, let’s say we have this function in our package:\nWhen people want to use our function, they need to have numpy installed for it to work, otherwise it will raise a ModuleNotFoundError on their machine.\nSo in order to ensure they get numpy installed, we set numpy as a dependency of our package. The dependencies of a package are listed in the pyproject.toml file. If you don’t know what that is, check out organizing a package.\nWith uv, we just have to run:\nThis will automatically add numpy to our pyproject.toml.\nIf we add other dependencies, they will be added to the dependencies list.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Handling dependencies</span>"
    ]
  },
  {
    "objectID": "unit-tests.html",
    "href": "unit-tests.html",
    "title": "4  Unit tests",
    "section": "",
    "text": "This page is a work in progress. You can see the current state of the project here.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Unit tests</span>"
    ]
  },
  {
    "objectID": "writing-documentation.html",
    "href": "writing-documentation.html",
    "title": "5  Writing documentation",
    "section": "",
    "text": "This page is a work in progress. You can see the current state of the project here.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Writing documentation</span>"
    ]
  },
  {
    "objectID": "errors-and-warnings.html",
    "href": "errors-and-warnings.html",
    "title": "6  Errors and warnings",
    "section": "",
    "text": "This page is a work in progress. You can see the current state of the project here.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Errors and warnings</span>"
    ]
  },
  {
    "objectID": "github-actions.html",
    "href": "github-actions.html",
    "title": "7  Github Actions",
    "section": "",
    "text": "This page is a work in progress. You can see the current state of the project here.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Github Actions</span>"
    ]
  },
  {
    "objectID": "pre-commit.html",
    "href": "pre-commit.html",
    "title": "8  Pre-commit",
    "section": "",
    "text": "This page is a work in progress. You can see the current state of the project here.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Pre-commit</span>"
    ]
  },
  {
    "objectID": "api-design.html",
    "href": "api-design.html",
    "title": "9  API design",
    "section": "",
    "text": "This page is a work in progress. You can see the current state of the project here.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>API design</span>"
    ]
  },
  {
    "objectID": "publish-to-pypi.html",
    "href": "publish-to-pypi.html",
    "title": "10  Publish to PyPI",
    "section": "",
    "text": "This page is a work in progress. You can see the current state of the project here.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Publish to PyPI</span>"
    ]
  },
  {
    "objectID": "handling-dependencies.html#specify-dependencies",
    "href": "handling-dependencies.html#specify-dependencies",
    "title": "3  Handling dependencies",
    "section": "",
    "text": "import numpy as np\n\ndef normalize(array):\n   min_val = np.min(array)\n   max_val = np.max(array)\n   return (array - min_val) / (max_val - min_val)\n\n\n\nuv add numpy\n\n\nBeforeAfter\n\n\n[project]\nname = \"mypackage\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.13\"\ndependencies = []\n\n\n[project]\nname = \"mypackage\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.13\"\ndependencies = [\n    \"numpy&gt;=2.2.4\",\n]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Handling dependencies</span>"
    ]
  },
  {
    "objectID": "handling-dependencies.html#avoiding-dependencies",
    "href": "handling-dependencies.html#avoiding-dependencies",
    "title": "3  Handling dependencies",
    "section": "3.2 Avoiding dependencies",
    "text": "3.2 Avoiding dependencies\nIn general, we want to avoid having too many dependencies. Why is that? Because when we install a package, we need to install its dependencies too, as well as the dependencies of those packages, and so on.\nThe issue with this is that it adds a lot complexity quickly and increase the risk of having conflicts.\nFor example, one package might need a version of numpy before &lt;2.0.0, while another need a version above or equal to &gt;=2.2.0. This kind of situation can quickly arise if not careful when adding too many dependencies, and it’s usually a nightmare to resolve.\n\nNote: packages with low or no dependencies are called lightweight. As an example, have a look at the narwhals package.\n\nThe thing with having lots of dependencies is that it makes it easier for you to write code because you can use other people code super easily. So it’s always a trade-off somehow.\nAlways ask yourself those questions before adding a new package to your dependencies:\n\nis the dependency a well-known, stable package (numpy, requests, etc) or is it new and is likely to change in the future?\ndoes this dependency has lots of dependencies too? This might be a red flag 🚩\ncan’t you just code what it does yourself? If you only need a single function, go check their source code on Github and see if it’s easy to do on your side (and ensure their License allow you to copy the code too).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Handling dependencies</span>"
    ]
  },
  {
    "objectID": "handling-dependencies.html#control",
    "href": "handling-dependencies.html#control",
    "title": "3  Handling dependencies",
    "section": "3.3 Control",
    "text": "3.3 Control",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Handling dependencies</span>"
    ]
  },
  {
    "objectID": "handling-dependencies.html#controlling-the-versions",
    "href": "handling-dependencies.html#controlling-the-versions",
    "title": "3  Handling dependencies",
    "section": "3.3 Controlling the versions",
    "text": "3.3 Controlling the versions\nWhat’s the difference between numpy 2.1.0 and numpy 2.0.0? Well, many things, but for example, in numpy 2.0.0, the np.unstack() function doesn’t exist as it’s a new one from numpy 2.1.0.\nIf our package relies on np.unstack() in one of our functions, we can’t let people install any numpy version when installing our package. We need to ensure people install this version: numpy&gt;=2.1.0. If we translate it, it means any version of numpy above or equal to 2.1.0. Let’s see some other examples.\n\nnumpy==2.1.0numpy&lt;=2.1.0numpy&gt;=2.1.0,&lt;2.2.0numpy\n\n\nInstall exactly this version of numpy.\nuv pip install numpy==2.1.0\n\n\nInstall the latest available version before 2.1.0 (including 2.1.0) of numpy.\nuv pip install 'numpy&lt;=2.1.0'\n\n\nInstall the latest version between 2.1.0 (included) and 2.2.0 (excluded) of numpy.\nuv pip install 'numpy&gt;=2.1.0,&lt;2.2.0'\n\n\nInstall the latest version of numpy.\nuv pip install numpy\n\n\n\nNote that for each of those, the package resolver will always try to install the latest version it can depending on the other dependencies. If another package requires numpy&lt;=2.1.0, other packages must include numpy 2.1.0 for it to work.\nBut you might ask, how do I know which versions of each dependencies are required for my package? Well, as far as I know, there is no easy answer to this, but there are ways to ensure you don’t get unexpected behaviors.\n\n3.3.1 Set the minimum version required…\nFor each of your dependencies, set in your pyproject.toml the minimum version required. With uv, you can run the following to install a specific version:\nuv pip install numpy==2.0.0\n\nWarning: the command above will install a specific version of numpy, but will not change the requirements in pyproject.toml.\n\n\n\n3.3.2 … test your code…\nYou have to test that your code works as expected on those versions. The best way to do that is unit testing, and it’s the point of the next blog post.\n\n\n3.3.3 … and be convenient\n\nDependening on whether you’re planning on distributing your package (e.g., put it on PyPI and allow other people to install it) or not, you might want to do different things here. We’ll assume you want to distribute it at the end.\n\nWhen your package goaled is to be installed by other people, you want to be convenient. By that I mean not being too restrictive.\nIf we take our example from before, we know that we need at least numpy==2.1.0 for our package to work, but we also know that any numpy version above works too. For this reason, we set numpy&gt;=2.1.0 instead of numpy==2.1.0 to allow a broader range of possibility.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Handling dependencies</span>"
    ]
  },
  {
    "objectID": "handling-dependencies.html#breaking-changes",
    "href": "handling-dependencies.html#breaking-changes",
    "title": "3  Handling dependencies",
    "section": "3.4 Breaking changes",
    "text": "3.4 Breaking changes\nBy default, when installing our package, it will try to find the latest numpy version that satisfies the requirements.\nBut, you might say there’s a risk it will break on a new numpy version? Yes, it absolutely does. And that’s exactly we said earlier why we wanted to avoid having too many dependencies and use stable ones.\nThe good thing with packages like numpy is that it’s one of the most important Python package and one of its core component. They can’t make breaking changes on any significant feature. When they want to do it, they usually add warnings like this: “The function xxx is deprecated and will be removed in a future version, please use yyy instead?”.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Handling dependencies</span>"
    ]
  },
  {
    "objectID": "handling-dependencies.html#required-optional-and-dev-dependencies",
    "href": "handling-dependencies.html#required-optional-and-dev-dependencies",
    "title": "3  Handling dependencies",
    "section": "3.5 Required, Optional and Dev dependencies",
    "text": "3.5 Required, Optional and Dev dependencies",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Handling dependencies</span>"
    ]
  }
]